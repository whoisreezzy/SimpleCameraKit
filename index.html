<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1" />
  <title>Camera Kit — fullscreen</title>
  <style>
    /* 100% безопасное полноэкранное полотно с учётом мобильных браузеров */
    :root { color-scheme: dark; }
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      background: #000; overflow: hidden;
    }
    /* Используем динамические viewport-единицы, чтобы не ломало из-за адресной строки */
    #c {
      position: fixed; inset: 0; display: block;
      width: 100vw; height: 100dvh; /* fallback ниже */
    }
    @supports not (height: 100dvh) {
      #c { height: 100vh; } 
    }
    /* На iOS учитываем вырезы экрана */
    body { padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <script type="module">
    const CONFIG = {
      apiToken:   (import.meta.env && import.meta.env.VITE_CAMERA_KIT_TOKEN) || '',
      lensId:     (import.meta.env && import.meta.env.VITE_LENS_ID) || '',
      groupId:    (import.meta.env && import.meta.env.VITE_LENS_GROUP_ID) || undefined
    };

    import {
      bootstrapCameraKit,
      createMediaStreamSource,
      Transform2D,
    } from '@snap/camera-kit';

    const canvas = document.getElementById('c');
    let sourceRef = null;
    let sessionRef = null;
    let cameraKitRef = null;
    let mediaRef = null;
    let lastPixelW = 0, lastPixelH = 0;
    let __ckReady = false;

    function resize(){
      // Без зеркала на канвасе — фильтр остаётся как есть
      canvas.style.transform = 'none';
      canvas.style.transformOrigin = 'center';
    }
    // Безопасно обновляем рендер‑размер после изменения viewport
    let __resizeTimer = null;
    async function updateRenderSize(){
      if (!__ckReady) return; // ещё не инициализировано — тихо выходим
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      const pxW = Math.floor(rect.width * dpr);
      const pxH = Math.floor(rect.height * dpr);

      lastPixelW = pxW; lastPixelH = pxH;
      if (!sourceRef) return;
      try { await sourceRef.setRenderSize(pxW, pxH); } catch(e){ console.warn('[CameraKit] setRenderSize failed:', e); }
    }
    function queueRenderResize(){
      clearTimeout(__resizeTimer);
      __resizeTimer = setTimeout(updateRenderSize, 60);
    }
    // Обновляем размер при ресайзе окна, смене ориентации и изменении визуального viewport (iOS)
    window.addEventListener('resize', ()=>{ resize(); queueRenderResize(); }, { passive:true });
    window.addEventListener('orientationchange', ()=>{ setTimeout(()=>{ resize(); queueRenderResize(); }, 50); }, { passive:true });
    if (window.visualViewport){
      window.visualViewport.addEventListener('resize', ()=>{ setTimeout(()=>{ resize(); queueRenderResize(); }, 50); }, { passive:true });
    }
    resize();
    queueRenderResize();

    async function rebuildSession(pxW, pxH){
      if (!cameraKitRef) { console.warn('[CameraKit] rebuildSession called before bootstrap — skipped'); return; }
      if (!sourceRef) return;
      try { await sourceRef.setRenderSize(pxW, pxH); } catch(e){ console.warn('[CameraKit] setRenderSize failed:', e); }
    }

    (async()=>{
      try{
        if(!CONFIG.apiToken) throw new Error('Нет API Token. Укажите VITE_CAMERA_KIT_TOKEN в переменных окружения (Netlify) или .env.local');

        cameraKitRef = await bootstrapCameraKit({ apiToken: CONFIG.apiToken });
        __ckReady = true;

        mediaRef = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'user' }, audio: false
        });

        // Если линза рисуется зеркально, подадим зеркальный источник и раззеркалим превью CSS-ом.
        const source = createMediaStreamSource(mediaRef, {
          transform: Transform2D.MirrorX,
          cameraType: 'front'
        });
        sourceRef = source;

        // Первая и единственная передача управления OffscreenCanvas: задаём bitmap‑размер ДО createSession
        const dpr0 = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        const r0 = canvas.getBoundingClientRect();
        lastPixelW = Math.floor(r0.width * dpr0);
        lastPixelH = Math.floor(r0.height * dpr0);
        try { canvas.width = lastPixelW; canvas.height = lastPixelH; } catch(_) { /* ignore */ }

        // Создаём сессию ОДИН раз и больше не пересоздаём
        sessionRef = await cameraKitRef.createSession({ liveRenderTarget: canvas });
        await sessionRef.setSource(sourceRef);
        try { await sourceRef.setRenderSize(lastPixelW, lastPixelH); } catch(_){}

        // ---- Load/apply lens (minimal) ----
        if (CONFIG.lensId) {
          try {
            const { lens } = CONFIG.groupId
              ? await cameraKitRef.lensRepository.loadLens(CONFIG.lensId, CONFIG.groupId)
              : await cameraKitRef.lensRepository.loadLens(CONFIG.lensId);
            await sessionRef.applyLens(lens);
          } catch (_) {
            // тихо пропускаем, если линза недоступна
          }
        }

        await sessionRef.play();

        window.addEventListener('beforeunload', ()=>{
          try { if (sessionRef) { sessionRef.pause(); sessionRef.destroy(); } } catch(_){}
          try { if (mediaRef) { mediaRef.getTracks().forEach(t=>t.stop()); } } catch(_){}
        });
      }catch(err){
        console.error('[CameraKit]', err);
      }
    })();
  </script>
</body>
</html>
