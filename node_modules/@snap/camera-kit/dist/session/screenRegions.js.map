{"version":3,"file":"screenRegions.js","sourceRoot":"","sources":["../../src/session/screenRegions.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,QAAQ,EAAE,MAAM,sBAAsB,CAAC;AAmGhD,MAAM,mBAAmB,GAAuD;IAC5E,WAAW,EAAE,cAAc;IAC3B,MAAM,EAAE,SAAS;IACjB,QAAQ,EAAE,UAAU;IACpB,UAAU,EAAE,aAAa;IACzB,iBAAiB,EAAE,qBAAqB;CAC3C,CAAC;AAUF,MAAM,UAAU,eAAe,CAAC,KAAc;IAC1C,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC;QAAE,OAAO,KAAK,CAAC;IAEnC,KAAK,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;QAC7C,IAAI,CAAC,CAAC,GAAG,IAAI,mBAAmB,CAAC;YAAE,OAAO,KAAK,CAAC;QAChD,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC;YAAE,OAAO,KAAK,CAAC;KACjD;IACD,OAAO,IAAI,CAAC;AAChB,CAAC;AAED,MAAM,GAAG,GAAG,IAAI,CAAC;AAEjB,MAAM,cAAc,GAAG,CAAC,CAAU,EAAe,EAAE,CAAC,OAAO,CAAC,KAAK,QAAQ,IAAI,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;AAEhG,SAAS,oBAAoB,CAAC,GAAY;IACtC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC;QAAE,OAAO,KAAK,CAAC;IAGjC,MAAM,CAAC,GAAI,GAAW,CAAC,CAAC,CAAC;IACzB,MAAM,CAAC,GAAI,GAAW,CAAC,CAAC,CAAC;IACzB,MAAM,KAAK,GAAI,GAAW,CAAC,KAAK,CAAC;IACjC,MAAM,MAAM,GAAI,GAAW,CAAC,MAAM,CAAC;IAGnC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC,KAAK,CAAC,cAAc,CAAC;QAAE,OAAO,KAAK,CAAC;IAG/D,IAAI,KAAK,GAAG,CAAC,IAAI,MAAM,GAAG,CAAC;QAAE,OAAO,KAAK,CAAC;IAG1C,MAAM,EAAE,GAAG,CAAC,GAAG,KAAK,CAAC;IACrB,MAAM,EAAE,GAAG,CAAC,GAAG,MAAM,CAAC;IAEtB,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG;QAAE,OAAO,KAAK,CAAC;IACvC,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG;QAAE,OAAO,KAAK,CAAC;IAC7C,IAAI,EAAE,GAAG,CAAC,GAAG,GAAG,IAAI,EAAE,GAAG,CAAC,GAAG,GAAG;QAAE,OAAO,KAAK,CAAC;IAE/C,OAAO,IAAI,CAAC;AAChB,CAAC;AAaD,MAAM,UAAU,0BAA0B,CAAC,UAAyB;IAChE,MAAM,aAAa,GAA0C,EAAE,CAAC;IAChE,KAAK,MAAM,CAAC,UAAU,EAAE,MAAM,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;QAC3D,MAAM,kBAAkB,GAAG,mBAAmB,CAAC,UAA8B,CAAC,CAAC;QAE/E,aAAa,CAAC,kBAAkB,CAAC,GAAG;YAChC,cAAc,EAAE;gBACZ,MAAM,EAAE;oBACJ,CAAC,EAAE,MAAM,CAAC,CAAC;oBACX,CAAC,EAAE,MAAM,CAAC,CAAC;iBACd;gBACD,IAAI,EAAE;oBACF,KAAK,EAAE,MAAM,CAAC,KAAK;oBACnB,MAAM,EAAE,MAAM,CAAC,MAAM;iBACxB;aACJ;SACJ,CAAC;KACL;IACD,OAAO,aAAa,CAAC;AACzB,CAAC","sourcesContent":["import { isRecord } from \"../common/typeguards\";\nimport type {\n    ScreenRegionType as LensCoreScreenRegionType,\n    ScreenRegionsInput as LensCoreScreenRegionsInput,\n} from \"../lens-core-module/generated-types\";\n\n/**\n * Defines the types of screen regions that can be configured for Lens rendering.\n *\n * - `roundButton`: Circular UI buttons (e.g., capture button)\n * - `topBar`: Top navigation or status bar area\n * - `keyboard`: Virtual keyboard area when shown\n * - `safeRender`: Safe area for Lens content to avoid UI overlap\n * - `captureExitButton`: Exit button for capture mode\n */\nexport type ScreenRegionType = \"roundButton\" | \"topBar\" | \"keyboard\" | \"safeRender\" | \"captureExitButton\";\n\n/**\n * Represents a screen region with its normalized rectangular bounds.\n *\n * All coordinates are normalized values between 0.0 and 1.0 relative to the canvas size.\n * For example, { x: 0.5, y: 0.5, width: 0.5, height: 0.5 } represents right-bottom quarter of the canvas.\n */\nexport interface ScreenRegion {\n    /**\n     * Normalized x-coordinate of the region's top-left corner (0.0 to 1.0).\n     */\n    x: number;\n    /**\n     * Normalized y-coordinate of the region's top-left corner (0.0 to 1.0).\n     */\n    y: number;\n    /**\n     * Normalized width of the region (0.0 to 1.0).\n     */\n    width: number;\n    /**\n     * Normalized height of the region (0.0 to 1.0).\n     */\n    height: number;\n}\n\n/**\n * Configuration for screen regions used by Lenses.\n *\n * Screen regions help Lenses adapt their content placement based on the host\n * application's UI layout. All coordinates are normalized (0.0 to 1.0) relative\n * to the canvas dimensions.\n *\n * Only the regions specified in this object will be active - any previously set\n * regions not included will be automatically removed.\n *\n * @example\n * ```typescript\n * // Set initial safe rendering area\n * await session.setScreenRegions({\n *   safeRender: {\n *     x: 0.1,\n *     y: 0.1,\n *     width: 0.8,\n *     height: 0.8\n *   }\n * });\n *\n * // When keyboard appears, update both regions\n * await session.setScreenRegions({\n *   safeRender: {\n *     x: 0.1,\n *     y: 0.1,\n *     width: 0.8,\n *     height: 0.5\n *   },\n *   keyboard: {\n *     x: 0,\n *     y: 0.5,\n *     width: 1.0,\n *     height: 0.5\n *   }\n * });\n *\n * // When keyboard disappears, only specify safeRender\n * // (keyboard region will be automatically removed)\n * await session.setScreenRegions({\n *   safeRender: {\n *     x: 0.1,\n *     y: 0.1,\n *     width: 0.8,\n *     height: 0.8\n *   }\n * });\n * ```\n */\nexport type ScreenRegions = {\n    [K in ScreenRegionType]?: ScreenRegion;\n};\n\n// Mapping between JavaScript-friendly API names and LensCore internal names\n// This allows us to present a clean camelCase API while maintaining compatibility\n// with the underlying LensCore system that uses snake_case naming\nconst REGION_TYPE_MAPPING: Record<ScreenRegionType, LensCoreScreenRegionType> = {\n    roundButton: \"round_button\",\n    topBar: \"top_bar\",\n    keyboard: \"keyboard\",\n    safeRender: \"safe_render\",\n    captureExitButton: \"capture_exit_button\",\n};\n\n/**\n * Type guard to validate ScreenRegions input.\n *\n * - Ensures `value` is a record\n * - Ensures every key is a known ScreenRegionType (via REGION_TYPE_MAPPING)\n * - Ensures every value is a normalized rect in [0,1], non-negative size,\n *   and fits within the canvas (with tiny epsilon tolerance)\n */\nexport function isScreenRegions(value: unknown): value is ScreenRegions {\n    if (!isRecord(value)) return false;\n\n    for (const [key, rect] of Object.entries(value)) {\n        if (!(key in REGION_TYPE_MAPPING)) return false;\n        if (!isNormalizedRectLike(rect)) return false;\n    }\n    return true;\n}\n\nconst EPS = 1e-6;\n\nconst isFiniteNumber = (v: unknown): v is number => typeof v === \"number\" && Number.isFinite(v);\n\nfunction isNormalizedRectLike(obj: unknown): obj is ScreenRegion {\n    if (!isRecord(obj)) return false;\n\n    // Pull fields as unknowns first\n    const x = (obj as any).x;\n    const y = (obj as any).y;\n    const width = (obj as any).width;\n    const height = (obj as any).height;\n\n    // Shape + type checks\n    if (![x, y, width, height].every(isFiniteNumber)) return false;\n\n    // Non-negative size\n    if (width < 0 || height < 0) return false;\n\n    // Bounds with small epsilon tolerance\n    const x2 = x + width;\n    const y2 = y + height;\n\n    if (x < -EPS || y < -EPS) return false;\n    if (x > 1 + EPS || y > 1 + EPS) return false;\n    if (x2 > 1 + EPS || y2 > 1 + EPS) return false;\n\n    return true;\n}\n\n/**\n * Handles the complete logic for updating screen regions.\n *\n * This function implements the \"current state\" pattern where only the regions\n * specified in newRegions will be active, and any previously set regions\n * not included will be automatically removed.\n *\n * @param newRegions - The new screen regions to set (public API format)\n * @param currentRegions - The currently active screen regions (for tracking)\n * @returns Object containing LensCore input and updated current regions\n */\nexport function prepareScreenRegionsUpdate(newRegions: ScreenRegions): LensCoreScreenRegionsInput[\"regions\"] {\n    const mappedRegions: LensCoreScreenRegionsInput[\"regions\"] = {};\n    for (const [regionType, region] of Object.entries(newRegions)) {\n        const lensCoreRegionType = REGION_TYPE_MAPPING[regionType as ScreenRegionType];\n        // LensCore expects regions wrapped in a normalizedRect property\n        mappedRegions[lensCoreRegionType] = {\n            normalizedRect: {\n                origin: {\n                    x: region.x,\n                    y: region.y,\n                },\n                size: {\n                    width: region.width,\n                    height: region.height,\n                },\n            },\n        };\n    }\n    return mappedRegions;\n}\n"]}